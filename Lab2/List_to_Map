object MyObject {

    def main(args: Array[String]) {
        val progLang = List("C++", "JavaScript" , "Scala" , "Python")
        val map = progLang.zipWithIndex.map{ case (v,i) => (i,v) }.toMap
        println("The values of map : "+ map)
    }
}


This Scala code defines an object named MyObject with a main method. When executed, this program does the following:

It creates a list called progLang containing four strings: "C++", "JavaScript", "Scala", and "Python".
It then uses the zipWithIndex method on progLang. This method pairs each element of the list with its index,
creating a list of tuples. In this case, it would look like this: List((C++,0), (JavaScript,1), (Scala,2), (Python,3)).
Next, it uses the map function on this list of tuples. For each tuple, it applies a function specified by { case (v,i) => (i,v) }.
In this function, v represents the value (in this case, the programming language), and i represents the index. So, it swaps the
positions of the value and index in each tuple. After this mapping operation, you'll have a list of tuples that looks like this:
List((0,C++), (1,JavaScript), (2,Scala), (3,Python)).
Finally, it converts this list of tuples into a Map using the .toMap method. This means that each index becomes a key, and the
corresponding programming language becomes the value in the resulting Map. At the end of the program, it prints out the content of the map.

In the given Scala code, case is a keyword used in a pattern matching expression. Pattern matching is a powerful feature in Scala that allows
you to match the structure of data against a pattern and perform different computations based on the match.
In the specific line of code:
scala
val map = progLang.zipWithIndex.map { case (v, i) => (i, v) }.toMap
Here, the case keyword is used to destructure each tuple generated by zipWithIndex. The pattern (v, i) is used to extract the value (v) and
the index (i) from each tuple. This is known as a pattern match. It's a concise way to handle each element of the list generated by zipWithIndex.

In this context, case is used within a lambda function passed to the map method. It's shorthand for defining a function that takes a tuple and
extracts its components (v and i) to construct a new tuple with swapped positions.

In the given Scala code, case is used as part of a pattern matching expression. Specifically, it is used within the map function as { case (v, i) => (i, v) }.

Here's what it means:
The case keyword is part of Scala's pattern matching syntax, which allows you to destructure data and match it against patterns.
In this context, (v, i) is a pattern that is being matched against each tuple element in the list. It's saying, "For each tuple in the list, bind
the first element (the value) to v and the second element (the index) to i."
After the pattern match, the expression => (i, v) specifies what to do with the matched elements. In this case, it's creating a new tuple where
the index i is the first element, and the value v is the second element.
So, the case keyword is an essential part of pattern matching in Scala, allowing you to destructure and transform data in a concise and
expressive way. In the given code, it's used to swap the positions of values and indices in each tuple.



Converting List to map by merging two list
We can create a map by using two lists and merging them to create a map. For creation, we will add using one of the lists as key and other as
value for the key-value pairs of the map.
The list to be used as the key in the map should have unique elements and both the lists should have the same number of elements.
Syntax:
    map_name = (list1_name zip list2_name).toMap
Program to convert lists to map

object MyObject {

    def main(args: Array[String]) {
        val myBikes = List("ThunderBird 350" , "YRF R3" , "S1000RR")
        val topSpeed = List(132 , 167 , 300)
        val bikeSpeed = (myBikes zip topSpeed).toMap
        println("The values of map : "+ bikeSpeed)
    }
}